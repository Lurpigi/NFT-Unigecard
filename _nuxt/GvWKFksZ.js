import{K as S,n as q,r as O,p as N,q as _,s as $,u as d}from"./BChm8QdC.js";import{c as w}from"./CpFsRuOh.js";import{B as f,C as g}from"./Cyp0RKsw.js";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const M=t=>typeof t<"u",I=S;function V(t){var n;const r=S(t);return(n=r==null?void 0:r.$el)!=null?n:r}function W(t){return JSON.parse(JSON.stringify(t))}function J(t,n,r,c={}){var o,i,e;const{clone:s=!1,passive:l=!1,eventName:m,deep:b=!1,defaultValue:P,shouldEmit:x}=c,u=q(),A=r||(u==null?void 0:u.emit)||((o=u==null?void 0:u.$emit)==null?void 0:o.bind(u))||((e=(i=u==null?void 0:u.proxy)==null?void 0:i.$emit)==null?void 0:e.bind(u==null?void 0:u.proxy));let p=m;p=p||`update:${n.toString()}`;const T=a=>s?typeof s=="function"?s(a):W(a):a,E=()=>M(t[n])?T(t[n]):P,F=a=>{x?x(a)&&A(p,a):A(p,a)};if(l){const a=E(),v=O(a);let h=!1;return N(()=>t[n],y=>{h||(h=!0,v.value=T(y),$(()=>h=!1))}),N(v,y=>{!h&&(y!==t[n]||b)&&F(y)},{deep:b}),v}else return _({get(){return E()},set(a){F(a)}})}function R(){const t=q(),n=O(),r=_(()=>{var e,s;return["#text","#comment"].includes((e=n.value)==null?void 0:e.$el.nodeName)?(s=n.value)==null?void 0:s.$el.nextElementSibling:V(n)}),c=Object.assign({},t.exposed),o={};for(const e in t.props)Object.defineProperty(o,e,{enumerable:!0,configurable:!0,get:()=>t.props[e]});if(Object.keys(c).length>0)for(const e in c)Object.defineProperty(o,e,{enumerable:!0,configurable:!0,get:()=>c[e]});Object.defineProperty(o,"$el",{enumerable:!0,configurable:!0,get:()=>t.vnode.el}),t.exposed=o;function i(e){n.value=e,e&&(Object.defineProperty(o,"$el",{enumerable:!0,configurable:!0,get:()=>e instanceof Element?e:e.$el}),t.exposed=o)}return{forwardRef:i,currentRef:n,currentElement:r}}function G(){return{getMyNFTs:async()=>{const r=d().public.proxyAddress;if(typeof window.ethereum>"u")throw new Error("Wallet non rilevato");await window.ethereum.request({method:"eth_requestAccounts"});const o=await new f(window.ethereum).getSigner(),i=new g(r,w,o),[e,s]=await i.getMyNFTs();return{ids:e,amounts:s}}}}function k(){const n=d().public.proxyAddress;if(typeof window.ethereum>"u")throw new Error("Wallet non rilevato");return new Promise(async(r,c)=>{try{await window.ethereum.request({method:"eth_requestAccounts"});const i=await new f(window.ethereum).getSigner(),s=await new g(n,w,i).getTotalMyNFTs();r(s)}catch(o){c(o)}})}function D(t){const r=d().public.proxyAddress;if(typeof window.ethereum>"u")throw new Error("Wallet non rilevato");return new Promise(async(c,o)=>{try{await window.ethereum.request({method:"eth_requestAccounts"});const e=await new f(window.ethereum).getSigner(),l=await new g(r,w,e).getTotalNFTsOf(t);c(l)}catch(i){o(i)}})}async function K(){const n=d().public.proxyAddress;if(typeof window.ethereum>"u")throw new Error("Wallet non rilevato");return new Promise(async(r,c)=>{try{await window.ethereum.request({method:"eth_requestAccounts"});const i=await new f(window.ethereum).getSigner(),s=await new g(n,w,i).getPointer();r(s)}catch(o){c(o)}})}async function U(t,n){const c=d().public.proxyAddress;if(typeof window.ethereum>"u")throw new Error("Wallet non rilevato");try{await window.ethereum.request({method:"eth_requestAccounts"});const i=await new f(window.ethereum).getSigner(),e=new g(c,w,i),l=await e.MINT_FEE()*BigInt(n),m=await e.mint4To(t,n,{value:l});return await m.wait(),m}catch(o){throw o}}export{D as a,K as b,V as c,J as d,G as e,k as g,U as m,I as t,R as u};
